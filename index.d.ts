// Generated by "bundle-dts@1.1.1" https://github.com/fishen/bundle-dts#readme."
declare module "auto-mapping/src/constants" {
    export const DESIGN_PARAM_TYPES = "design:paramtypes";
    export const DESIGN_TYPE = "design:type";
    export const DESIGN_RETURN_TYPE = "design:returntype";
    export const CURRENT_PATH = ".";
    export const DEFAULT_PROPERTY_SEP = ".";
    export const DEFAULT_SOURCE: any;
    export const PROPERTIES_KEY: any;
    export const MAPPING: any;
    export const MAPPED: any;
    export const DEFAULT_ORDER = 0;
}
declare module "auto-mapping/src/reflect" {
    import "reflect-metadata";
    const reflect: typeof Reflect;
    export default reflect;
}
declare module "auto-mapping/src/utils" {
    export function validAssign(source: any, dest: any): any;
    export function pushByOrder<T>(array: T[], item: T, selector: (item: T) => any): T[];
    export function isNil(value: any): boolean;
    export function isValid(value: any, options?: {
        nullable?: boolean;
        allowNaN?: boolean;
    }): any;
    export enum DecoractorTarget {
        argument = "argument",
        class = "class",
        gettter = "gettter",
        method = "method",
        property = "property",
        setter = "setter"
    }
    export function isFn(target: any): target is Function;
    export function isObj(target: any, canBeNull?: boolean): target is object;
    export function isNum(target: any, canBeNaN?: boolean): target is number;
    export function isStr(target: any): target is string;
    export function checkDecoractorTarget(decoractor: string, ...targets: DecoractorTarget[]): (target: any, name?: string, descriptor?: PropertyDescriptor) => void;
    export function isGetter(target: any, name: string, descriptor: PropertyDescriptor): any;
}
declare module "auto-mapping/src/property" {
    import { Converter, IMappingOptions, IProperty, PropertyType } from "auto-mapping/src/interface";
    export class Property<T> implements IProperty<T> {
        static from<T>(options: IProperty<T> | Converter<T>, target: any, name: string): Property<unknown>;
        /**
         * Get the properties bound on the prototype object
         * @param prototype prototype object
         * @param options mapping options
         */
        static getProperties<T>(prototype: object, options?: IMappingOptions): Array<Property<T>>;
        path: string;
        type: PropertyType<T>;
        default: any;
        order: number;
        name: string;
        source: string | symbol;
        /**
         * The conversion function
         * @param src source value
         * @param dest dest value
         * @param options mapping options
         */
        convert(src: any, dest: T, options?: IMappingOptions): any;
    }
}
declare module "auto-mapping/src/converter" {
    import { Converter, IMappingOptions, PropertyType } from "auto-mapping/src/interface";
    /**
     * Global conversion function container
     */
    export const CONVERTERS: any;
    /**
     * Get the conversion function of the specified type.
     * @param type conversion type
     * @param options mapping options
     */
    export function getConverter<T>(type: PropertyType<T>, options: IMappingOptions): Converter<T>;
    /**
     * Map an object to an instance of the specified type.
     * @param src Data source object.
     * @param constuctor The type of instance, the constructor function of the class.
     * @param options Mapping options.
     */
    export function map<T extends new (...args: any[]) => any>(src: any, constuctor: T, options?: IMappingOptions): InstanceType<T> | null;
    export namespace map {
        var setDefaultConverter: (type: PropertyType<any>, converter: Converter<any>) => void;
    }
}
declare module "auto-mapping/src/decorator" {
    import { Converter, IProperty } from "auto-mapping/src/interface";
    /**
     * The required annotations for object mapping which can only be used on instance properties.
     * @param options mapping options
     */
    export function mapping<T = any>(options?: IProperty<T> | Converter<T>): (target: any, name?: string, descriptor?: PropertyDescriptor) => void;
}
declare module "auto-mapping" {
    export { mapping } from "auto-mapping/src/decorator";
    export { map } from "auto-mapping/src/converter";
    export { DEFAULT_SOURCE, MAPPED, MAPPING, MAPPED as after } from "auto-mapping/src/constants";
    export { Converter, PropertyType } from "auto-mapping/src/interface";
}