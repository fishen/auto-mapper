// Generated by "bundle-dts@1.1.3" https://github.com/fishen/bundle-dts#readme."
declare module "auto-mapping/src/constants" {
    export const DESIGN_PARAM_TYPES = "design:paramtypes";
    export const DESIGN_TYPE = "design:type";
    export const DESIGN_RETURN_TYPE = "design:returntype";
    export const CURRENT_PATH = ".";
    export const DEFAULT_PROPERTY_SEP = ".";
    export const DEFAULT_SOURCE: unique symbol;
    export const PROPERTIES_KEY: unique symbol;
    export const MAPPING: unique symbol;
    export const MAPPED: unique symbol;
    export const DEFAULT_ORDER = 0;
}
declare module "auto-mapping/src/interface" {
    export type Converter<T = any> = (value: any, src: any, dest: T, options: IMappingOptions) => any;
    export type PropertyType<T = any> = new (...args: any[]) => T;
    export interface IProperty<T = any> {
        /**
         * Default value, multiple data sources can specify multiple different default values.
         */
        default?: any;
        /**
         * The parent path of current property, the resulting path is `${domain}.${currentPropertyKey}`
         * The option domain will be ignored when used with path.
         */
        domain?: string;
        /**
         * The order for the property generated
         * @default 0
         */
        order?: number;
        /**
         * The property path in the source object, such as 'a.b.c','a.b[0].c',
         * @default current property name.
         */
        path?: string;
        /**
         * The source object name,
         * it is required if you want to map data from multiple data sources.
         * @default DEFAULT_SOURCE
         */
        source?: string | symbol;
        /**
         * The property decalre type, it is always necessary if the property type is an array.
         * such as String, [Number]
         */
        type?: PropertyType<T> | Converter<T> | [PropertyType<T>] | [Converter<T>];
    }
    export interface IMappingOptions {
        /**
         * Whether enable debug mode.
         */
        debug?: boolean;
        /**
         * The source object name, it is required if you want to map data from multiple data sources.
         * @default DEFAULT_SOURCE
         */
        source?: string | symbol;
        /**
         * Use the default mapping configuration when the current source configuration is missing.
         * @default true
         */
        useDefaultSource?: boolean;
        /**
         * Whether to allow the value to be set to null
         */
        nullable?: boolean;
        /**
         * Whether to allow the value to be set to NaN
         */
        allowNaN?: boolean;
        /**
         * Custom conversion function, only valid during the current mapping.
         * If you want to set a global conversion function, use the 'map.setDefaultConverter' function.
         */
        converters?: Map<PropertyType, Converter>;
    }
}
declare module "auto-mapping/src/reflect" {
    import "reflect-metadata";
    const reflect: typeof Reflect;
    export default reflect;
}
declare module "auto-mapping/src/utils" {
    export function validAssign(source: any, dest: any): any;
    export function pushByOrder<T>(array: T[], item: T, selector: (item: T) => any): T[];
    export function isNil(value: any): boolean;
    export function isValid(value: any, options?: {
        nullable?: boolean;
        allowNaN?: boolean;
    }): boolean;
    export function isFn(target: any): target is Function;
    export function isObj(target: any, canBeNull?: boolean): target is object;
    export function isNum(target: any, canBeNaN?: boolean): target is number;
    export function isStr(target: any): target is string;
}
declare module "auto-mapping/src/property" {
    import { Converter, IProperty, PropertyType } from "auto-mapping/src/interface";
    export class Property<T> implements IProperty<T> {
        static from<T>(options: IProperty<T> | Converter<T>, target: any, name: string): Property<unknown>;
        path: string;
        type: PropertyType<T>;
        default: any;
        order: number;
        name: string;
        source: string | symbol;
    }
}
declare module "auto-mapping/src/converter" {
    import { Converter, IMappingOptions, PropertyType } from "auto-mapping/src/interface";
    import { Property } from "auto-mapping/src/property";
    export class Mapper<T extends new (...args: any[]) => any> {
        static converters: Map<PropertyType<any>, Converter<any>>;
        /**
         * Get the properties bound on the prototype object
         * @param prototype prototype object
         * @param options mapping options
         */
        static getProperties<T>(prototype: object, options?: IMappingOptions): Property<T>[];
        data: any;
        instance: any;
        ctor: T;
        prototype: any;
        options?: IMappingOptions;
        customConverter: (...args: any) => any;
        constructor(instance: any, data: any, ctor: T, options?: IMappingOptions);
        map(): any;
        private hasProperties;
        private getConverter;
        private getPropertyValue;
        private getMappedResult;
        private isValidSourceData;
    }
    /**
     * Map an object to an instance of the specified type.
     * @param src Data source object.
     * @param constuctor The type of instance, the constructor function of the class.
     * @param options Mapping options.
     */
    export function map<T extends new (...args: any[]) => any>(src: any, constuctor: T, options?: IMappingOptions): InstanceType<T> | null;
    export namespace map {
        var setDefaultConverter: (type: PropertyType<any>, converter: Converter<any>) => void;
    }
    /**
     * Map an object to another object which only has the mapped property.
     * @param src Data source object.
     * @param constuctor The type of instance, the constructor function of the class.
     * @param options Mapping options.
     */
    export function select<T extends new (...args: any[]) => any>(src: any, constuctor: T, options?: IMappingOptions): Partial<InstanceType<T>> | null;
}
declare module "auto-mapping/src/decorator" {
    import { Converter, IProperty } from "auto-mapping/src/interface";
    /**
     * The required annotations for object mapping which can only be used on instance properties.
     * @param options mapping options
     */
    export function mapping<T = any>(options?: IProperty<T> | Converter<T>): (target: any, name?: string) => void;
}
declare module "auto-mapping" {
    export { mapping } from "auto-mapping/src/decorator";
    export { map, select } from "auto-mapping/src/converter";
    export { DEFAULT_SOURCE, MAPPED, MAPPING, MAPPED as after } from "auto-mapping/src/constants";
    export { Converter, PropertyType } from "auto-mapping/src/interface";
}